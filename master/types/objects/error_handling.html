<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Error handling - Juniper Book (GraphQL server for Rust)</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="User guide for Juniper (GraphQL server library for Rust).">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../../quickstart.html"><strong aria-hidden="true">2.</strong> Quickstart</a></li><li class="chapter-item expanded "><a href="../../types/index.html"><strong aria-hidden="true">3.</strong> Type System</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/objects/defining_objects.html"><strong aria-hidden="true">3.1.</strong> Defining objects</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/objects/complex_fields.html"><strong aria-hidden="true">3.1.1.</strong> Complex fields</a></li><li class="chapter-item expanded "><a href="../../types/objects/using_contexts.html"><strong aria-hidden="true">3.1.2.</strong> Using contexts</a></li><li class="chapter-item expanded "><a href="../../types/objects/error_handling.html" class="active"><strong aria-hidden="true">3.1.3.</strong> Error handling</a></li></ol></li><li class="chapter-item expanded "><a href="../../types/other-index.html"><strong aria-hidden="true">3.2.</strong> Other types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../types/enums.html"><strong aria-hidden="true">3.2.1.</strong> Enums</a></li><li class="chapter-item expanded "><a href="../../types/interfaces.html"><strong aria-hidden="true">3.2.2.</strong> Interfaces</a></li><li class="chapter-item expanded "><a href="../../types/input_objects.html"><strong aria-hidden="true">3.2.3.</strong> Input objects</a></li><li class="chapter-item expanded "><a href="../../types/scalars.html"><strong aria-hidden="true">3.2.4.</strong> Scalars</a></li><li class="chapter-item expanded "><a href="../../types/unions.html"><strong aria-hidden="true">3.2.5.</strong> Unions</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../schema/schemas_and_mutations.html"><strong aria-hidden="true">4.</strong> Schemas and mutations</a></li><li class="chapter-item expanded "><a href="../../servers/index.html"><strong aria-hidden="true">5.</strong> Adding A Server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../servers/official.html"><strong aria-hidden="true">5.1.</strong> Official Server Integrations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../servers/warp.html"><strong aria-hidden="true">5.1.1.</strong> Warp</a></li><li class="chapter-item expanded "><a href="../../servers/rocket.html"><strong aria-hidden="true">5.1.2.</strong> Rocket</a></li><li class="chapter-item expanded "><a href="../../servers/iron.html"><strong aria-hidden="true">5.1.3.</strong> Iron</a></li><li class="chapter-item expanded "><a href="../../servers/hyper.html"><strong aria-hidden="true">5.1.4.</strong> Hyper</a></li></ol></li><li class="chapter-item expanded "><a href="../../servers/third-party.html"><strong aria-hidden="true">5.2.</strong> Third Party Integrations</a></li></ol></li><li class="chapter-item expanded "><a href="../../advanced/index.html"><strong aria-hidden="true">6.</strong> Advanced Topics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../advanced/introspection.html"><strong aria-hidden="true">6.1.</strong> Introspection</a></li><li class="chapter-item expanded "><a href="../../advanced/non_struct_objects.html"><strong aria-hidden="true">6.2.</strong> Non-struct objects</a></li><li class="chapter-item expanded "><a href="../../advanced/implicit_and_explicit_null.html"><strong aria-hidden="true">6.3.</strong> Implicit and explicit null</a></li><li class="chapter-item expanded "><a href="../../advanced/objects_and_generics.html"><strong aria-hidden="true">6.4.</strong> Objects and generics</a></li><li class="chapter-item expanded "><a href="../../advanced/multiple_ops_per_request.html"><strong aria-hidden="true">6.5.</strong> Multiple operations per request</a></li><li class="chapter-item expanded "><a href="../../advanced/dataloaders.html"><strong aria-hidden="true">6.6.</strong> Dataloaders</a></li><li class="chapter-item expanded "><a href="../../advanced/subscriptions.html"><strong aria-hidden="true">6.7.</strong> Subscriptions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Juniper Book (GraphQL server for Rust)</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>Error handling in GraphQL can be done in multiple ways. In the
following two different error handling models are discussed: field
results and GraphQL schema backed errors. Each approach has its
advantages. Choosing the right error handling method depends on the
requirements of the application--investigating both approaches is
beneficial.</p>
<h2 id="field-results"><a class="header" href="#field-results">Field Results</a></h2>
<p>Rust
<a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html">provides</a>
two ways of dealing with errors: <code>Result&lt;T, E&gt;</code> for recoverable errors and
<code>panic!</code> for unrecoverable errors. Juniper does not do anything about panicking;
it will bubble up to the surrounding framework and hopefully be dealt with
there.</p>
<p>For recoverable errors, Juniper works well with the built-in <code>Result</code> type, you
can use the <code>?</code> operator and things will generally just work as you expect them to:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate juniper;
</span>use std::{
    str,
    path::PathBuf,
    fs::{File},
    io::{Read},
};
use juniper::{graphql_object, FieldResult};

struct Example {
    filename: PathBuf,
}

#[graphql_object]
impl Example {
    fn contents(&amp;self) -&gt; FieldResult&lt;String&gt; {
        let mut file = File::open(&amp;self.filename)?;
        let mut contents = String::new();
        file.read_to_string(&amp;mut contents)?;
        Ok(contents)
    }

    fn foo() -&gt; FieldResult&lt;Option&lt;String&gt;&gt; {
        // Some invalid bytes.
        let invalid = vec![128, 223];

        Ok(Some(str::from_utf8(&amp;invalid)?.to_string()))
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p><code>FieldResult&lt;T&gt;</code> is an alias for <code>Result&lt;T, FieldError&gt;</code>, which is the error
type all fields must return. By using the <code>?</code> operator or <code>try!</code> macro, any type
that implements the <code>Display</code> trait - which are most of the error types out
there - those errors are automatically converted into <code>FieldError</code>.</p>
<h2 id="error-payloads-null-and-partial-errors"><a class="header" href="#error-payloads-null-and-partial-errors">Error payloads, <code>null</code>, and partial errors</a></h2>
<p>Juniper's error behavior conforms to the <a href="https://spec.graphql.org/October2021#sec-Handling-Field-Errors">GraphQL specification</a>.</p>
<p>When a field returns an error, the field's result is replaced by <code>null</code>, an
additional <code>errors</code> object is created at the top level of the response, and the
execution is resumed. For example, with the previous example and the following
query:</p>
<pre><code class="language-graphql">{
  example {
    contents
    foo
  }
}
</code></pre>
<p>If <code>str::from_utf8</code> resulted in a <code>std::str::Utf8Error</code>, the following would be
returned:</p>
<p>!FILENAME Response for nullable field with error</p>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;example&quot;: {
      contents: &quot;&lt;Contents of the file&gt;&quot;,
      foo: null
    }
  },
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;invalid utf-8 sequence of 2 bytes from index 0&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<p>If an error is returned from a non-null field, such as the
example above, the <code>null</code> value is propagated up to the first nullable parent
field, or the root <code>data</code> object if there are no nullable fields.</p>
<p>For example, with the following query:</p>
<pre><code class="language-graphql">{
  example {
    contents
  }
}
</code></pre>
<p>If <code>File::open()</code> above resulted in <code>std::io::ErrorKind::PermissionDenied</code>, the
following would be returned:</p>
<p>!FILENAME Response for non-null field with error and no nullable parent</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [
    &quot;message&quot;: &quot;Permission denied (os error 13)&quot;,
    &quot;locations&quot;: [{ &quot;line&quot;: 2, &quot;column&quot;: 4 }])
  ]
}
</code></pre>
<h3 id="structured-errors"><a class="header" href="#structured-errors">Structured errors</a></h3>
<p>Sometimes it is desirable to return additional structured error information
to clients. This can be accomplished by implementing <a href="https://docs.rs/juniper/latest/juniper/trait.IntoFieldError.html"><code>IntoFieldError</code></a>:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#[macro_use] extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, FieldError, IntoFieldError, ScalarValue};
</span><span class="boring">
</span>enum CustomError {
    WhateverNotSet,
}

impl&lt;S: ScalarValue&gt; IntoFieldError&lt;S&gt; for CustomError {
    fn into_field_error(self) -&gt; FieldError&lt;S&gt; {
        match self {
            CustomError::WhateverNotSet =&gt; FieldError::new(
                &quot;Whatever does not exist&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;NO_WHATEVER&quot;
                }),
            ),
        }
    }
}

struct Example {
    whatever: Option&lt;bool&gt;,
}

#[graphql_object]
impl Example {
    fn whatever(&amp;self) -&gt; Result&lt;bool, CustomError&gt; {
        if let Some(value) = self.whatever {
            return Ok(value);
        }
        Err(CustomError::WhateverNotSet)
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>The specified structured error information is included in the <a href="https://spec.graphql.org/October2021#sec-Errors"><code>extensions</code></a> key:</p>
<pre><code class="language-json">{
  &quot;errors&quot;: [{
    &quot;message&quot;: &quot;Whatever does not exist&quot;,
    &quot;locations&quot;: [{&quot;line&quot;: 2, &quot;column&quot;: 4}],
    &quot;extensions&quot;: {
      &quot;type&quot;: &quot;NO_WHATEVER&quot;
    }
  }]
}
</code></pre>
<h2 id="errors-backed-by-graphqls-schema"><a class="header" href="#errors-backed-by-graphqls-schema">Errors Backed by GraphQL's Schema</a></h2>
<p>Rust's model of errors can be adapted for GraphQL. Rust's panic is
similar to a <code>FieldError</code>--the whole query is aborted and nothing can
be extracted (except for error related information).</p>
<p>Not all errors require this strict handling. Recoverable or partial errors can be put
into the GraphQL schema so the client can intelligently handle them.</p>
<p>To implement this approach, all errors must be partitioned into two error classes:</p>
<ul>
<li>Critical errors that cannot be fixed by the user (e.g. a database error).</li>
<li>Recoverable errors that can be fixed by the user (e.g. invalid input data).</li>
</ul>
<p>Critical errors are returned from resolvers as <code>FieldErrors</code> (from the previous section). Non-critical errors are part of the GraphQL schema and can be handled gracefully by clients. Similar to Rust, GraphQL allows similar error models with unions (see Unions).</p>
<h3 id="example-input-validation-simple"><a class="header" href="#example-input-validation-simple">Example Input Validation (simple)</a></h3>
<p>In this example, basic input validation is implemented with GraphQL
types. Strings are used to identify the problematic field name. Errors
for a particular field are also returned as a string. In this example
the string contains a server-side localized error message. However, it is also
possible to return a unique string identifier and have the client present a localized string to the user.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject, GraphQLUnion};
</span><span class="boring">
</span>#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationError {
    field: String,
    message: String,
}

#[derive(GraphQLObject)]
pub struct ValidationErrors {
    errors: Vec&lt;ValidationError&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationErrors),
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; GraphQLResult {
        let mut errors = Vec::new();

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            errors.push(ValidationError {
                field: &quot;name&quot;.into(),
                message: &quot;between 10 and 100&quot;.into(),
            });
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            errors.push(ValidationError {
                field: &quot;quantity&quot;.into(),
                message: &quot;between 1 and 10&quot;.into(),
            });
        }

        if errors.is_empty() {
            GraphQLResult::Ok(Item { name, quantity })
        } else {
            GraphQLResult::Err(ValidationErrors { errors })
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<p>Each function may have a different return type and depending on the input
parameters a new result type is required. For example, adding a user
requires a new result type which contains the variant <code>Ok(User)</code>
instead of <code>Ok(Item)</code>.</p>
<p>The client can send a mutation request and handle the
resulting errors as shown in the following example:</p>
<pre><code class="language-graphql">{
  mutation {
    addItem(name: &quot;&quot;, quantity: 0) {
      ... on Item {
        name
      }
      ... on ValidationErrors {
        errors {
          field
          message
        }
      }
    }
  }
}
</code></pre>
<p>A useful side effect of this approach is to have partially successful
queries or mutations. If one resolver fails, the results of the
successful resolvers are not discarded.</p>
<h3 id="example-input-validation-complex"><a class="header" href="#example-input-validation-complex">Example Input Validation (complex)</a></h3>
<p>Instead of using strings to propagate errors, it is possible to use
GraphQL's type system to describe the errors more precisely.</p>
<p>For each fallible input variable a field in a GraphQL object is created. The
field is set if the validation for that particular field fails. You will likely want some kind of code generation to reduce repetition as the number of types required is significantly larger than
before. Each resolver function has a custom <code>ValidationResult</code> which
contains only fields provided by the function.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate juniper;
</span><span class="boring">use juniper::{graphql_object, GraphQLObject, GraphQLUnion};
</span><span class="boring">
</span>#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationError {
    name: Option&lt;String&gt;,
    quantity: Option&lt;String&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationError),
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; GraphQLResult {
        let mut error = ValidationError {
            name: None,
            quantity: None,
        };

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            error.name = Some(&quot;between 10 and 100&quot;.into());
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            error.quantity = Some(&quot;between 1 and 10&quot;.into());
        }

        if error.name.is_none() &amp;&amp; error.quantity.is_none() {
            GraphQLResult::Ok(Item { name, quantity })
        } else {
            GraphQLResult::Err(error)
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<pre><code class="language-graphql">{
  mutation {
    addItem {
      ... on Item {
        name
      }
      ... on ValidationErrorsItem {
        name
        quantity
      }
    }
  }
}
</code></pre>
<p>Expected errors are handled directly inside the query. Additionally, all
non-critical errors are known in advance by both the server and the client.</p>
<h3 id="example-input-validation-complex-with-critical-error"><a class="header" href="#example-input-validation-complex-with-critical-error">Example Input Validation (complex with critical error)</a></h3>
<p>Our examples so far have only included non-critical errors. Providing
errors inside the GraphQL schema still allows you to return unexpected critical
errors when they occur.</p>
<p>In the following example, a theoretical database could fail
and would generate errors. Since it is not common for the database to
fail, the corresponding error is returned as a critical error:</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">extern crate juniper;
</span><span class="boring">
</span>use juniper::{graphql_object, graphql_value, FieldError, GraphQLObject, GraphQLUnion, ScalarValue};

#[derive(GraphQLObject)]
pub struct Item {
    name: String,
    quantity: i32,
}

#[derive(GraphQLObject)]
pub struct ValidationErrorItem {
    name: Option&lt;String&gt;,
    quantity: Option&lt;String&gt;,
}

#[derive(GraphQLUnion)]
pub enum GraphQLResult {
    Ok(Item),
    Err(ValidationErrorItem),
}

pub enum ApiError {
    Database,
}

impl&lt;S: ScalarValue&gt; juniper::IntoFieldError&lt;S&gt; for ApiError {
    fn into_field_error(self) -&gt; FieldError&lt;S&gt; {
        match self {
            ApiError::Database =&gt; FieldError::new(
                &quot;Internal database error&quot;,
                graphql_value!({
                    &quot;type&quot;: &quot;DATABASE&quot;
                }),
            ),
        }
    }
}

pub struct Mutation;

#[graphql_object]
impl Mutation {
    fn addItem(&amp;self, name: String, quantity: i32) -&gt; Result&lt;GraphQLResult, ApiError&gt; {
        let mut error = ValidationErrorItem {
            name: None,
            quantity: None,
        };

        if !(10 &lt;= name.len() &amp;&amp; name.len() &lt;= 100) {
            error.name = Some(&quot;between 10 and 100&quot;.into());
        }

        if !(1 &lt;= quantity &amp;&amp; quantity &lt;= 10) {
            error.quantity = Some(&quot;between 1 and 10&quot;.into());
        }

        if error.name.is_none() &amp;&amp; error.quantity.is_none() {
            Ok(GraphQLResult::Ok(Item { name, quantity }))
        } else {
            Ok(GraphQLResult::Err(error))
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}</span></code></pre></pre>
<h2 id="additional-material"><a class="header" href="#additional-material">Additional Material</a></h2>
<p>The <a href="https://shopify.dev/docs/admin-api/graphql/reference">Shopify API</a>
implements a similar approach. Their API is a good reference to
explore this approach in a real world application.</p>
<h1 id="comparison"><a class="header" href="#comparison">Comparison</a></h1>
<p>The first approach discussed above--where every error is a critical error defined by <code>FieldResult</code> --is easier to implement. However, the client does not know what errors may occur and must instead infer what happened from the error string. This is brittle and could change over time due to either the client or server changing. Therefore, extensive integration testing between the client and server is required to maintain the implicit contract between the two.</p>
<p>Encoding non-critical errors in the GraphQL schema makes the contract between the client and the server explicit. This allows the client to understand and handle these errors correctly and the server to know when changes are potentially breaking clients. However, encoding this error information into the GraphQL schema requires additional code and up-front definition of non-critical errors.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../types/objects/using_contexts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../types/other-index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../types/objects/using_contexts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../types/other-index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
